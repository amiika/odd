# How to FZRTH: Rhythm & Structure

First we built a browser-based live coding environment that could compile a string of numbers into a sequence of sine waves. It was efficient, running entirely on the Audio Thread, but it could only play sequences in a fixed time.

To make the sequences more musical, we need two things: **Time** (rhythm, tempo / bpm) and **Structure** (notes, chords, patterns). In this part, we will expand our interpreter into a Forth-like language capable of complex rhythmic synthesis.

## 1. The Pulse: BPM and Anchor Timing

The first feature we need is a way to control time. In the dictionary, the `bpm` operator is simple: it pops a number from the stack and sets the state.

```javascript
'bpm': function(c) { c.bpm = resolve(c.stack.pop()) || 120; },
```

However, the hard part is changing the tempo on the fly. If you simply calculate `Time * BPM`, changing the tempo causes the beat count to jump backward or forward with the simple implementation.

To fix this, we use **Anchor Timing**. Inside our audio loop, we detect if `bpm` has changed. If it has, we "freeze" the current progress into `anchorBeat` and reset the `anchorFrame` to "now".

```javascript
// Inside process(inputs, outputs) ...

// 1. Detect Change
if (this.bpm !== this.lastBpm) {
    const prevRate = this.lastBpm / (60 * sampleRate);
    
    // 2. Calculate progress made since the last anchor
    const beatNow = this.anchorBeat + (currentFrame - this.anchorFrame) * prevRate;
    
    // 3. Drop the anchor
    this.anchorBeat = beatNow;
    this.anchorFrame = currentFrame;
    this.lastBpm = this.bpm;
}

// 4. Calculate absolute beat time using the new anchor
const beatsPerSample = this.bpm / (60 * sampleRate);
const totalBeats = this.anchorBeat + (currentFrame - this.anchorFrame) * beatsPerSample;
```

This ensures that `totalBeats` is always a continuous, smooth line, no matter how you change the tempo.

## 2. Stack operators

A Forth-like languages are using something called Reverse Polish Notation (RPN). So for example `1 2 + 3 *` is `9`. You push values into a stack and operators consume them and push the values back to the stack. Adding standard operators allows more complex data flows.

* `dup`: Duplicates the top item (`10 dup` -> `10 10`).
* `drop`: Discards the top item (`10 drop`-> NADA).
* `swap`: Swaps the top two items (`10 20 swap` -> `20 10`).

```javascript
'dup':  (c) => { if (c.stack.length) c.stack.push(c.stack[c.stack.length-1]); },
'drop': (c) => c.stack.pop(),
'swap': (c) => { const a=c.stack.pop(), b=c.stack.pop(); c.stack.push(a, b); },
```

## 3. The Language: Definitions and Loops

To make this a real language, we need to be able to define new words and loop over values.

### Custom Words `: ... ;`
The colon operator reads the *next* token as the name, and compiles everything until the semicolon into a reusable function.

```javascript
':': function(c, s) { 
    const name = s.shift(), body = [];
    while(s.length) { 
        const t = s.shift(); 
        if(t === ';') break; 
        body.push(t); 
    }
    // Register a new function that runs this body of tokens
    c.dict[name] = (ctx) => this.run([...body], ctx);
},
```

## 4. Stack Principles & Recursive Math

Finally, we need structures to organize frequencies in time. We introduce three container types:

1.  **`seq` (Sequence):** Subdivides **one beat** into equal parts (e.g., 16th notes).
2.  **`cycle` (Cycle):** Spans **multiple beats** (e.g., one note per beat).
3.  **`chord` (Chord):** Stacks items vertically (plays all simultaneously).

The rendering engine uses a recursive function `getFreqs` to traverse these structures. Every audio frame, it asks: *"Given that we are at Beat 4.25, what frequencies should be playing?"*

```javascript
getFreqs(node, beatPhase, beatIndex) {
    if (typeof node === 'number') return [node];
    
    // CHORD: Return all children flattened
    if (node.type === CHO) {
        return node.data.flatMap(n => this.getFreqs(n, beatPhase, beatIndex));
    }
    
    // SEQUENCE: Use fractional beat (beatPhase) to pick index
    if (node.type === SEQ) {
        const idx = Math.floor(beatPhase * node.data.length) % node.data.length;
        // Recurse with faster time
        return this.getFreqs(node.data[idx], (beatPhase * node.data.length) % 1, beatIndex);
    }
    
    // CYCLE: Use integer beat (beatIndex) to pick index
    if (node.type === CYC) {
        const idx = beatIndex % node.data.length;
        return this.getFreqs(node.data[idx], beatPhase, beatIndex);
    }
    return [];
}
```

This traversal allows for infinite nesting. A `seq` can contain a `cycle` which contains a `chord`â€”creating complex polymetric rhythms from simple lists.

The rendering engine uses a recursive function `getFreqs` to traverse these structures. Every audio frame, it asks: *"Given that we are at Beat 4.25, what frequencies should be playing?"*

```javascript
getFreqs(node, beatPhase, beatIndex) {
    if (typeof node === 'number') return [node];
    
    // CHORD: Return all children flattened
    if (node.type === CHO) {
        return node.data.flatMap(n => this.getFreqs(n, beatPhase, beatIndex));
    }
    
    // SEQUENCE: Use fractional beat (beatPhase) to pick index
    if (node.type === SEQ) {
        const idx = Math.floor(beatPhase * node.data.length) % node.data.length;
        // Recurse with faster time
        return this.getFreqs(node.data[idx], (beatPhase * node.data.length) % 1, beatIndex);
    }
    
    // CYCLE: Use integer beat (beatIndex) to pick index
    if (node.type === CYC) {
        const idx = beatIndex % node.data.length;
        return this.getFreqs(node.data[idx], beatPhase, beatIndex);
    }
    return [];
}
```

### Recursive Math

In generative music, you often want to apply an operation to a whole group of notes. Instead of writing a loop to add 50Hz to every note in a chord, we want our math operators to be "structure-aware".

We implement a helper `calc` that handles this recursion automatically.

```javascript
const calc = (c, fn) => {
    const b = c.stack.pop(), a = c.stack.pop();
    
    const map = (x, y) => {
        // If both are numbers, calculate immediately
        if (typeof x === 'number' && typeof y === 'number') return fn(x, y);
        
        // Ff one is a container, recurse the operation deeper
        if (y?.data) return { ...y, data: y.data.map(i => map(x, i)) };
        if (x?.data) return { ...x, data: x.data.map(i => map(i, y)) };
        
        // Defer: if we can't solve it yet, save it as an Operation Node
        return { type: 'OP', fn, args: [x, y] };
    }
    c.stack.push(map(a, b));
};
```

## Part 5: Demo

You can now use `seq`, `cycle`, and `chord` combined with `bpm` to create structured music.

Try this snippet. It creates a bassline that plays one note per beat (cycle), and a high arpeggio that plays 4 notes per beat (seq).

```fzrth
135 bpm
110 220 165 cycle sine
880 1100 1320 1760 seq sine
```

[Full Version](./source/0003/0003.html)

In Part 3, we will add Envelopes and Sample playback to turn our beeps into beats.

[Back to Index](./index.html)


<details>
<summary>Full source</summary>


HTML:
```html
<!DOCTYPE html>
<html>
<head>
    <title>FZRTH - 0002</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body { background: #000; color: #fb0; font-family: monospace; display: flex; flex-direction: column; height: 100vh; margin: 0; overflow: hidden; }
        #editor { flex: 1; background: #000; color: #fb0; border: none; padding: 20px; font-size: 20px; outline: none; resize: none; width: 100%; box-sizing: border-box; }
        .header { font-size: 24px; padding: 15px; border-bottom: 1px solid #fb0; display: flex; justify-content: space-between; align-items: center; background: #111;}
        ::selection { background: #fb0; color: #000; }
    </style>
</head>
<body>
    <div class="header">
        <div>FZRTH</div>
    </div>
    <textarea id="editor" spellcheck="false">
120 bpm

: bass 
  100 200 cycle 
  50 + ;    

: lead 
  300 400 500 seq ;

: pad 
  150 190 220 chord ;

bass sine
lead sine
pad sine</textarea>
    <script>
        const editor = document.getElementById('editor');
        let audioCtx;

        async function init() {
            if (audioCtx) return;
            try {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                
                // Load the Worklet file
                await audioCtx.audioWorklet.addModule('0002.js');
                
                const node = new AudioWorkletNode(audioCtx, 'fzrth-proc');
                node.connect(audioCtx.destination);
                
                // Live coding: send code on every keystroke
                editor.addEventListener('input', () => node.port.postMessage(editor.value));
                
                // Initial boot
                node.port.postMessage(editor.value);         
            } catch (e) {
                console.error("AudioWorklet Error:", e);
            }
        } 
        
        document.addEventListener('click', init, { once: true });
    </script>
</body>
</html>
```


AudioWorkletProcessor code:

```javascript
const SEQ = 'SEQ', CYC = 'CYC', CHO = 'CHO';

const DICT = {
    'sine': (c) => render(c),
    'bpm': function(c) { c.bpm = c.stack.pop() || 120; },
    ':': macro,
    'dup':  (c) => { if (c.stack.length) c.stack.push(c.stack[c.stack.length-1]); },
    'drop': (c) => c.stack.pop(),
    'swap': (c) => { const a=c.stack.pop(), b=c.stack.pop(); c.stack.push(a, b); },
    '+': (c) => calc(c, (a,b)=>a+b),
    '-': (c) => calc(c, (a,b)=>a-b),
    '*': (c) => calc(c, (a,b)=>a*b),
    '/': (c) => calc(c, (a,b)=>a/b),
    '%': (c) => calc(c, (a,b)=>a%b),
    'seq':   (c) => { const d=c.stack.splice(0); c.stack.push({type:SEQ, data:d}); },
    'cycle': (c) => { const d=c.stack.splice(0); c.stack.push({type:CYC, data:d}); },
    'chord': (c) => { const d=c.stack.splice(0); c.stack.push({type:CHO, data:d}); },
};

function render(c) {
    const data = c.stack.splice(0);
    if (!data.length) return;
    const pattern = data.length > 1 ? { type: SEQ, data } : data[0];
    c.sounds.push({ pattern, phases: [] });
}

function macro(c, s) { 
    const name = s.shift(), body = [];
    while(s.length) { 
        const t = s.shift(); 
        if(t === ';') break; 
        body.push(t); 
    }
    c.dict[name] = (ctx) => this.run([...body], ctx);
}

const calc = (c, fn) => {
    if (c.stack.length < 2) return;
    const b = c.stack.pop(), a = c.stack.pop();
    const map = (x, y) => {
        if (typeof x === 'number' && typeof y === 'number') return fn(x, y);
        if (y?.data) return { ...y, data: y.data.map(i => map(x, i)) };
        if (x?.data) return { ...x, data: x.data.map(i => map(i, y)) };
        return { type: 'OP', fn, args: [x, y] };
    }
    c.stack.push(map(a, b));
};

class ForthProcessor extends AudioWorkletProcessor {
    constructor() {
        super();
        this.sounds = [];
        this.bpm = 120;
        this.lastBpm = 120;
        this.anchorFrame = 0;
        this.anchorBeat = 0;
        
        this.port.onmessage = (e) => this.interpret(e.data);
    }

    interpret(text) {
        const ctx = { stack: [], loopStack: [], sounds: [], bpm: this.bpm };      
        const tokens = text.replace(/\(.*?\)/g, '').trim().split(/\s+/).filter(x => x);
      
        ctx.dict = Object.create(DICT);

        try { this.run(tokens, ctx); } catch(e) {}

        ctx.sounds.forEach((s, i) => { 
            if (this.sounds[i]) s.phases = this.sounds[i].phases; 
        });

        this.sounds = ctx.sounds;
        this.bpm = ctx.bpm;
    }

    run(tokens, ctx) {
        while(tokens.length) {
            const t = tokens.shift();
            const n = parseFloat(t);
            if (!isNaN(n)) {
                ctx.stack.push(n);
            } else if (ctx.dict[t]) {
                ctx.dict[t].call(this, ctx, tokens);
            }
        }
    }

    process(inputs, outputs) {
        const out = outputs[0][0];
        if (!out) return true;

        if (this.bpm !== this.lastBpm) {
            const prevRate = this.lastBpm / (60 * sampleRate);
            const beatNow = this.anchorBeat + (currentFrame - this.anchorFrame) * prevRate;
            this.anchorBeat = beatNow;
            this.anchorFrame = currentFrame;
            this.lastBpm = this.bpm;
        }

        const beatsPerSample = this.bpm / (60 * sampleRate);

        for (let i = 0; i < out.length; i++) {
            const absFrame = currentFrame + i;
            const totalBeats = this.anchorBeat + (absFrame - this.anchorFrame) * beatsPerSample;
            
            const beatIndex = Math.floor(totalBeats);
            const beatPhase = totalBeats % 1; 

            let sig = 0;
            this.sounds.forEach(snd => {
                const freqs = this.getFreqs(snd.pattern, beatPhase, beatIndex);
                
                freqs.forEach((f, ch) => {
                    if(!snd.phases[ch]) snd.phases[ch]=0;
                    snd.phases[ch] += (f/sampleRate);
                    sig += Math.sin(snd.phases[ch] * 6.28318);
                });
                // Truncate phases if voice count drops (e.g. seq ending)
                if(snd.phases.length > freqs.length) snd.phases.length = freqs.length;
            });
            out[i] = sig * 0.15;
        }
        return true;
    }

    getFreqs(node, beatPhase, beatIndex) {
        if (typeof node === 'number') return [node];
        if (node.type === 'OP') return [node];
        
        if (node.type === CHO) {
            return node.data.flatMap(n => this.getFreqs(n, beatPhase, beatIndex));
        }
        if (node.type === SEQ) {
            if (!node.data.length) return [];
            const idx = Math.floor(beatPhase * node.data.length) % node.data.length;
            // Recursively scale phase for the child
            return this.getFreqs(node.data[idx], (beatPhase * node.data.length) % 1, beatIndex);
        }
        if (node.type === CYC) {
            if (!node.data.length) return [];
            const idx = beatIndex % node.data.length;
            return this.getFreqs(node.data[idx], beatPhase, beatIndex);
        }
        return [];
    }
}
registerProcessor('fzrth-proc', ForthProcessor);
```

</details>