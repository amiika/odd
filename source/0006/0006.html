<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>BYTEBEAT TERMINAL</title>
    <style>
       body { 
            background: #000; 
            color: #0f0; 
            font-family: monospace; 
            margin: 0; 
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            box-sizing: border-box;
        }
        .container { width: 100%; max-width: 500px; }
        .head { display: flex; justify-content: space-between; font-size: 10px; margin-bottom: 5px; opacity: 0.5; }
        canvas { width: 100%; height: px; border: 1px solid #030; margin-bottom: 20px; }
        
        .controls { display: flex; gap: 40px; margin-bottom: 20px; font-size: 10px; }
        .control-group { flex: 1; }
        input[type="range"] { 
            width: 100%; 
            appearance: none; 
            background: #020; 
            height: 1px; 
            outline: none; 
            margin: 10px 0;
        }
        input[type="range"]::-webkit-slider-thumb { 
            appearance: none; 
            width: 8px; 
            height: 12px; 
            background: #0f0; 
            cursor: pointer;
        }

        .field { margin-bottom: 10px; }
        textarea { 
            width: 100%; 
            height: 100px;
            background: #000; 
            border: 1px solid #030; 
            border-bottom: 1px solid #0f0; 
            color: #0f0; 
            font-family: monospace; 
            font-size: 14px; 
            outline: none;
            padding: 10px;
            box-sizing: border-box;
            resize: vertical;
        }
        textarea:focus { border: 1px solid #060; border-bottom: 1px solid #0f0; }

        button { 
            background: transparent; 
            border: 1px solid #0f0; 
            color: #0f0; 
            font-family: monospace; 
            padding: 8px 20px; 
            cursor: pointer; 
            text-transform: uppercase;
            width: 30%;
            margin-bottom: 20px;
            position: relative;
            z-index: 99;
            float: right;
            overflow: hidden;
        }
        button:hover { background: #0f0; color: #000; }
        
        .presets { margin-top: 20px; font-size: 10px; opacity: 0.5; }
        .preset-link { cursor: pointer; text-decoration: underline; margin-right: 10px; }
        .preset-link:hover { opacity: 1; color: #fff; }
    </style>
</head>
<body>

    <div class="container">
        <div class="head">
            <span>LIVEBYTE</span>
            <span id="statusDisplay">STATUS: OFF</span>
        </div>
        
        <canvas id="visualizerCanvas"></canvas>

        <div class="controls">
            <div class="control-group">
                <div>SPEED: <span id="speedLabel">0.18</span></div>
                <input type="range" id="speedSlider" min="0.01" max="10.0" step="0.01" value="0.18">
            </div>
            <div class="control-group">
                <div>VOLUME: <span id="volumeLabel">25%</span></div>
                <input type="range" id="volumeSlider" min="0" max="1" step="0.01" value="0.5">
            </div>
        </div>

        <div class="field">
            <textarea id="codeInput" spellcheck="false" placeholder="ENTER_JS_LOGIC">t*(42&t>>10)</textarea>
        </div>

        <button id="mainToggle">EXECUTE</button>

        <div class="presets">
            CLASSICS: 
            <span class="preset-link" data-code="t*(42&t>>10)">42</span>
            <span class="preset-link" data-code="10*(t>>6|t|t>>(t>>16))+(7&t>>11)">NO SIN</span>
            <span class="preset-link" data-code="t>>5|t<<4|t&1023^1981|t-67>>4">LEMMINGS</span>
            <span class="preset-link" data-code="t * t / 23 & t * 12">BASE</span>
        </div>
    </div>

    <script>
        const workletCode = `
        class BytebeatProcessor extends AudioWorkletProcessor {
            static get parameterDescriptors() {
                return [
                    { 
                        name: 'volume', 
                        defaultValue: 0,
                        automationRate: 'a-rate'
                    },
                    { 
                        name: 'speed', 
                        defaultValue: 0.18,
                        automationRate: 'k-rate'
                    }
                ];
            }
            constructor() {
                super();
                this.time = 0;
                this.dsp = (t) => 0;
                this.port.onmessage = (event) => {
                    if (event.data.code) {
                        try {
                            const code = event.data.code.trim();
                            this.dsp = new Function('t', \`return \${code}\`);
                        } catch (err) {}
                    }
                };
            }
            process(inputs, outputs, parameters) {
                const output = outputs[0];
                const leftChannel = output[0];
                const rightChannel = output[1];
                
                const vol = parameters.volume;
                const delta = parameters.speed[0];

                if (leftChannel) {
                    for (let i = 0; i < leftChannel.length; i++) {
                        let result = 0;

                        try {
                            // Some bytebeat magic, or is like floor but faster
                            result = this.dsp(this.time | 0) | 0;
                        } catch (e) {}

                        // More 8-bit magic, essentially result % 256 / 256 maps to [-1.0, 1.0]
                        const sample = ((result & 255) - 128) / 128;

                        // Handling volume automation rate
                        const currentVolume = vol.length > 1 ? vol[i] : vol[0];

                        leftChannel[i] = sample * currentVolume;
                        if (rightChannel) rightChannel[i] = leftChannel[i];

                        // Increment time based on speed parameter
                        this.time += delta;
                    }

                    // About 25% of the time, send visualizer data
                    if (((this.time | 0) & 511) < 128) {
                        this.port.postMessage(leftChannel);
                    }
                }
                return true;
            }
        }
        registerProcessor("bytebeat-processor", BytebeatProcessor);`;

        let audioContext, bytebeatNode, isPlaying = false;
        let visualizerData = new Float32Array(128);

        async function initializeAudio() {
            audioContext = new AudioContext();
            const blob = new Blob([workletCode], { type: 'application/javascript' });
            const workletUrl = URL.createObjectURL(blob);
            await audioContext.audioWorklet.addModule(workletUrl);
            
            bytebeatNode = new AudioWorkletNode(audioContext, 'bytebeat-processor');
            bytebeatNode.connect(audioContext.destination);
            bytebeatNode.port.onmessage = (event) => { visualizerData = event.data; };

            updatecode();
            updateParameters();
        }

        function updatecode() {
            if (!bytebeatNode) return;
            const code = document.getElementById('codeInput').value;
            bytebeatNode.port.postMessage({ code });
        }
        
        function updateParameters() {
            const speed = parseFloat(document.getElementById('speedSlider').value);
            const rawVolume = parseFloat(document.getElementById('volumeSlider').value);
            const volume = Math.pow(rawVolume, 2);
            document.getElementById('speedLabel').innerText = speed.toFixed(2);
            document.getElementById('volumeLabel').innerText = Math.round(rawVolume * 100) + '%';
            
            if (!bytebeatNode) return;
            
            bytebeatNode.parameters.get('speed').setValueAtTime(speed, audioContext.currentTime);

            if (isPlaying) {
                bytebeatNode.parameters.get('volume').setTargetAtTime(volume, audioContext.currentTime, 0.5);
            }
        }

        document.getElementById('mainToggle').onclick = async () => {
            if (!audioContext) await initializeAudio();
            const vol = bytebeatNode.parameters.get('volume');
            const now = audioContext.currentTime;

            if (isPlaying) {
                vol.linearRampToValueAtTime(0, now + 0.1);
                document.getElementById('mainToggle').innerText = 'EXECUTE'; 
                document.getElementById('statusDisplay').innerText = 'STATUS: OFF';
                isPlaying = false;
            } else {
                audioContext.resume();
                const targetVolume = Math.pow(document.getElementById('volumeSlider').value, 2);
                vol.linearRampToValueAtTime(targetVolume, now + 0.1);
                document.getElementById('mainToggle').innerText = 'TERMINATE'; 
                document.getElementById('statusDisplay').innerText = 'STATUS: RUNNING';
                isPlaying = true;
            }
        };

        document.getElementById('codeInput').oninput = updatecode;
        document.getElementById('speedSlider').oninput = updateParameters;
        document.getElementById('volumeSlider').oninput = updateParameters;

        document.querySelectorAll('.preset-link').forEach(preset => {
            preset.onclick = () => { 
                document.getElementById('codeInput').value = preset.dataset.code.replace(/\\n/g, '\n'); 
                updatecode(); 
            };
        });

        const canvas = document.getElementById('visualizerCanvas');
        const canvasCtx = canvas.getContext('2d');

        function drawVisualizer() {
            canvas.width = canvas.clientWidth; 
            canvas.height = canvas.clientHeight;
            canvasCtx.strokeStyle = '#0f0'; 
            canvasCtx.lineWidth = 1;
            canvasCtx.beginPath();
            for (let i = 0; i < visualizerData.length; i++) {
                const x = (i / visualizerData.length) * canvas.width;
                const y = canvas.height / 2 - (visualizerData[i] * canvas.height / 2);
                if (i === 0) canvasCtx.moveTo(x, y);
                else canvasCtx.lineTo(x, y);
            }
            canvasCtx.stroke(); 
            requestAnimationFrame(drawVisualizer);
        }
        drawVisualizer();
    </script>
</body>
</html>