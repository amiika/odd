# How to FZRTH: Part 6 - How to Bytebeat?

In [Part 5](../source/0005.html), we added a `raw` command to our engine. To understand why that is powerful, we need to step outside our Forth abstraction and look at the raw byte level sound synthesis.

Bytebeat is a form of algorithmic music created by writing a single mathematical expression. It was discovered/popularized by Viznut in 2011.

Instead of oscillators, sequencers, or samples, you have a simple counter, t, which increments usually 8,000 or 44,100 times per second. You apply math (multiplication, division) and bitwise logic (AND, OR, bit-shifting) to t. The result is usually an 8-bit integer (0-255), which is then wrapped around and output as sound.

It turns code directly into raw waveforms. A simple line like t * (42 & t >> 10) can generate complex, evolving melodies and rhythms because the bitwise operators create fractal-like repetitions at different time scales.

In this chapter, we build simple standalone **Bytebeat Terminal** for live coding bytebeat. This simple web app demonstrates how to safely compile user math strings into audio in real-time and ways for visualizing the raw buffer output.

## 1. The Audio Worklet (The Engine)

The Audio Worklet runs in a separate process to ensure glitch-free timing. This is where the bytebeat binary magic happens.

### Parameter Descriptors
First, we define which parameters the audio engine can control. We use `a-rate` (audio rate) for smooth volume changes and `k-rate` (block rate) for speed, as speed doesn't need to change 44,000 times a second.

```javascript
static get parameterDescriptors() {
    return [
        { name: 'volume', defaultValue: 0, automationRate: 'a-rate' },
        { name: 'speed', defaultValue: 0.18, automationRate: 'k-rate' }
    ];
}
```

### Dynamic Compilation
This is the most critical part. We listen for messages from the UI. When the user types code, we create a `new Function` that takes time `t` as an argument. This essentially "injects" the user's math directly into the audio loop.

```javascript
this.port.onmessage = (event) => {
    if (event.data.code) {
        try {
            // "t" is the argument, "t * 4" is the body
            this.dsp = new Function('t', "return " + event.data.code.trim());
        } catch (err) {}
    }
};
```

### The Process Loop
We iterate through the output buffer (usually 128 samples at a time).

1.  **Calculate:** We run the user's function with the current time.
2.  **Cast to Integer:** `| 0` forces Javascript to treat the number as a 32-bit integer, essential for bytebeat bitwise logic.
3.  **Wrap to Float:** The classic bytebeat formula expects 8-bit output (0-255). We use modulo logic `(x & 255)` to wrap it, then shift it to the Web Audio range of `-1.0` to `1.0`. This is essentially same as doing `x % 256 / 256` on a calculator.

```javascript
    process(inputs, outputs, parameters) {
        const output = outputs[0];
        const left = output[0];
        const right = output[1];
        const vol = parameters.volume;
        const delta = parameters.speed[0];

        if (left) {
            for (let i = 0; i < left.length; i++) {
                let result = 0;

                try {
                    // Some bytebeat magic, like floor but faster
                    result = this.dsp(this.time | 0) | 0;
                } catch (e) {}

                // More 8-bit magic, essentially result % 256 / 256 maps to [-1.0, 1.0]
                const sample = ((result & 255) - 128) / 128;

                // Handling volume automation rate
                const currentVolume = vol.length > 1 ? vol[i] : vol[0];

                left[i] = sample * currentVolume;
                if (right) right[i] = left[i];

                // Increment time based on speed parameter
                this.time += delta;
            }

            // About 25% of the time, send visualizer data
            if (((this.time | 0) & 511) < 128) {
                this.port.postMessage(left);
            }
        }
        return true;
    }
}
```

## 2. The Visualization Loop

We cheat slightly here. Instead of analyzing the audio frequencies (FFT), we just send a snapshot of the raw waveform back to the main thread every few frames. This is performant and creates that "oscilloscope" look.

```javascript
// Send data roughly 25% of the time to save bandwidth
if (((this.time | 0) & 511) < 128) {
    this.port.postMessage(leftChannel);
}
```

On the main thread, we use a canvas loop to draw lines connecting these points.

```javascript
function drawVisualizer() {
    canvasCtx.beginPath();
    for (let i = 0; i < visualizerData.length; i++) {
        // Map array index to Width, audio value to Height
        const x = (i / visualizerData.length) * canvas.width;
        const y = canvas.height / 2 - (visualizerData[i] * canvas.height / 2);
        canvasCtx.lineTo(x, y);
    }
    canvasCtx.stroke(); 
    requestAnimationFrame(drawVisualizer);
}
```

## 3. The UI Glue

The HTML structure is minimal. We use `<input type="range">` sliders for control. The Javascript hook connects the UI to the Worklet parameters using the Web Audio API's `setValueAtTime`.

This ensures that when you slide the volume, it doesn't "crackle"â€”the audio engine smooths the transition automatically.

```javascript
function updateParameters() {
    // Smoothly ramp volume to target over 0.5 seconds
    bytebeatNode.parameters.get('volume')
        .setTargetAtTime(targetVolume, audioContext.currentTime, 0.5);
}
```

## 4. Live Demo

The classic 42 melody by viznut
```bytebeat
t*(42&t>>10)
```


[Open FULL version to see the visualizer](./source/0006/0006.html)

[Back to Index](./index.html)


<details>
<summary>Full source</summary>


HTML:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>BYTEBEAT TERMINAL</title>
    <style>
       body { 
            background: #000; 
            color: #0f0; 
            font-family: monospace; 
            margin: 0; 
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            box-sizing: border-box;
        }
        .container { width: 100%; max-width: 500px; }
        .head { display: flex; justify-content: space-between; font-size: 10px; margin-bottom: 5px; opacity: 0.5; }
        canvas { width: 100%; height: px; border: 1px solid #030; margin-bottom: 20px; }
        
        .controls { display: flex; gap: 40px; margin-bottom: 20px; font-size: 10px; }
        .control-group { flex: 1; }
        input[type="range"] { 
            width: 100%; 
            appearance: none; 
            background: #020; 
            height: 1px; 
            outline: none; 
            margin: 10px 0;
        }
        input[type="range"]::-webkit-slider-thumb { 
            appearance: none; 
            width: 8px; 
            height: 12px; 
            background: #0f0; 
            cursor: pointer;
        }

        .field { margin-bottom: 10px; }
        textarea { 
            width: 100%; 
            height: 100px;
            background: #000; 
            border: 1px solid #030; 
            border-bottom: 1px solid #0f0; 
            color: #0f0; 
            font-family: monospace; 
            font-size: 14px; 
            outline: none;
            padding: 10px;
            box-sizing: border-box;
            resize: vertical;
        }
        textarea:focus { border: 1px solid #060; border-bottom: 1px solid #0f0; }

        button { 
            background: transparent; 
            border: 1px solid #0f0; 
            color: #0f0; 
            font-family: monospace; 
            padding: 8px 20px; 
            cursor: pointer; 
            text-transform: uppercase;
            width: 30%;
            margin-bottom: 20px;
            position: relative;
            z-index: 99;
            float: right;
            overflow: hidden;
        }
        button:hover { background: #0f0; color: #000; }
        
        .presets { margin-top: 20px; font-size: 10px; opacity: 0.5; }
        .preset-link { cursor: pointer; text-decoration: underline; margin-right: 10px; }
        .preset-link:hover { opacity: 1; color: #fff; }
    </style>
</head>
<body>

    <div class="container">
        <div class="head">
            <span>LIVEBYTE</span>
            <span id="statusDisplay">STATUS: OFF</span>
        </div>
        
        <canvas id="visualizerCanvas"></canvas>

        <div class="controls">
            <div class="control-group">
                <div>SPEED: <span id="speedLabel">0.18</span></div>
                <input type="range" id="speedSlider" min="0.01" max="10.0" step="0.01" value="0.18">
            </div>
            <div class="control-group">
                <div>VOLUME: <span id="volumeLabel">25%</span></div>
                <input type="range" id="volumeSlider" min="0" max="1" step="0.01" value="0.5">
            </div>
        </div>

        <div class="field">
            <textarea id="codeInput" spellcheck="false" placeholder="ENTER_JS_LOGIC">t*(42&t>>10)</textarea>
        </div>

        <button id="mainToggle">EXECUTE</button>

        <div class="presets">
            CLASSICS: 
            <span class="preset-link" data-code="t*(42&t>>10)">42</span>
            <span class="preset-link" data-code="10*(t>>6|t|t>>(t>>16))+(7&t>>11)">NO SIN</span>
            <span class="preset-link" data-code="t>>5|t<<4|t&1023^1981|t-67>>4">LEMMINGS</span>
            <span class="preset-link" data-code="t * t / 23 & t * 12">BASE</span>
        </div>
    </div>

    <script>
        const workletCode = `
        class BytebeatProcessor extends AudioWorkletProcessor {
            static get parameterDescriptors() {
                return [
                    { 
                        name: 'volume', 
                        defaultValue: 0,
                        automationRate: 'a-rate'
                    },
                    { 
                        name: 'speed', 
                        defaultValue: 0.18,
                        automationRate: 'k-rate'
                    }
                ];
            }
            constructor() {
                super();
                this.time = 0;
                this.dsp = (t) => 0;
                this.port.onmessage = (event) => {
                    if (event.data.code) {
                        try {
                            const code = event.data.code.trim();
                            this.dsp = new Function('t', \`return \${code}\`);
                        } catch (err) {}
                    }
                };
            }
            process(inputs, outputs, parameters) {
                const output = outputs[0];
                const leftChannel = output[0];
                const rightChannel = output[1];
                
                const vol = parameters.volume;
                const delta = parameters.speed[0];

                if (leftChannel) {
                    for (let i = 0; i < leftChannel.length; i++) {
                        let result = 0;

                        try {
                            // Some bytebeat magic, or is like floor but faster
                            result = this.dsp(this.time | 0) | 0;
                        } catch (e) {}

                        // More 8-bit magic, essentially result % 256 / 256 maps to [-1.0, 1.0]
                        const sample = ((result & 255) - 128) / 128;

                        // Handling volume automation rate
                        const currentVolume = vol.length > 1 ? vol[i] : vol[0];

                        leftChannel[i] = sample * currentVolume;
                        if (rightChannel) rightChannel[i] = leftChannel[i];

                        // Increment time based on speed parameter
                        this.time += delta;
                    }

                    // About 25% of the time, send visualizer data
                    if (((this.time | 0) & 511) < 128) {
                        this.port.postMessage(leftChannel);
                    }
                }
                return true;
            }
        }
        registerProcessor("bytebeat-processor", BytebeatProcessor);`;

        let audioContext, bytebeatNode, isPlaying = false;
        let visualizerData = new Float32Array(128);

        async function initializeAudio() {
            audioContext = new AudioContext();
            const blob = new Blob([workletCode], { type: 'application/javascript' });
            const workletUrl = URL.createObjectURL(blob);
            await audioContext.audioWorklet.addModule(workletUrl);
            
            bytebeatNode = new AudioWorkletNode(audioContext, 'bytebeat-processor');
            bytebeatNode.connect(audioContext.destination);
            bytebeatNode.port.onmessage = (event) => { visualizerData = event.data; };

            updatecode();
            updateParameters();
        }

        function updatecode() {
            if (!bytebeatNode) return;
            const code = document.getElementById('codeInput').value;
            bytebeatNode.port.postMessage({ code });
        }
        
        function updateParameters() {
            const speed = parseFloat(document.getElementById('speedSlider').value);
            const rawVolume = parseFloat(document.getElementById('volumeSlider').value);
            const volume = Math.pow(rawVolume, 2);
            document.getElementById('speedLabel').innerText = speed.toFixed(2);
            document.getElementById('volumeLabel').innerText = Math.round(rawVolume * 100) + '%';
            
            if (!bytebeatNode) return;
            
            bytebeatNode.parameters.get('speed').setValueAtTime(speed, audioContext.currentTime);

            if (isPlaying) {
                bytebeatNode.parameters.get('volume').setTargetAtTime(volume, audioContext.currentTime, 0.5);
            }
        }

        document.getElementById('mainToggle').onclick = async () => {
            if (!audioContext) await initializeAudio();
            const vol = bytebeatNode.parameters.get('volume');
            const now = audioContext.currentTime;

            if (isPlaying) {
                vol.linearRampToValueAtTime(0, now + 0.1);
                document.getElementById('mainToggle').innerText = 'EXECUTE'; 
                document.getElementById('statusDisplay').innerText = 'STATUS: OFF';
                isPlaying = false;
            } else {
                audioContext.resume();
                const targetVolume = Math.pow(document.getElementById('volumeSlider').value, 2);
                vol.linearRampToValueAtTime(targetVolume, now + 0.1);
                document.getElementById('mainToggle').innerText = 'TERMINATE'; 
                document.getElementById('statusDisplay').innerText = 'STATUS: RUNNING';
                isPlaying = true;
            }
        };

        document.getElementById('codeInput').oninput = updatecode;
        document.getElementById('speedSlider').oninput = updateParameters;
        document.getElementById('volumeSlider').oninput = updateParameters;

        document.querySelectorAll('.preset-link').forEach(preset => {
            preset.onclick = () => { 
                document.getElementById('codeInput').value = preset.dataset.code.replace(/\\n/g, '\n'); 
                updatecode(); 
            };
        });

        const canvas = document.getElementById('visualizerCanvas');
        const canvasCtx = canvas.getContext('2d');

        function drawVisualizer() {
            canvas.width = canvas.clientWidth; 
            canvas.height = canvas.clientHeight;
            canvasCtx.strokeStyle = '#0f0'; 
            canvasCtx.lineWidth = 1;
            canvasCtx.beginPath();
            for (let i = 0; i < visualizerData.length; i++) {
                const x = (i / visualizerData.length) * canvas.width;
                const y = canvas.height / 2 - (visualizerData[i] * canvas.height / 2);
                if (i === 0) canvasCtx.moveTo(x, y);
                else canvasCtx.lineTo(x, y);
            }
            canvasCtx.stroke(); 
            requestAnimationFrame(drawVisualizer);
        }
        drawVisualizer();
    </script>
</body>
</html>
```


AudioWorkletProcessor code:

```javascript
class BytebeatProcessor extends AudioWorkletProcessor {
            static get parameterDescriptors() {
                return [
                    { 
                        name: 'volume', 
                        defaultValue: 0,
                        automationRate: 'a-rate'
                    },
                    { 
                        name: 'speed', 
                        defaultValue: 0.18,
                        automationRate: 'k-rate'
                    }
                ];
            }
            constructor() {
                super();
                this.time = 0;
                this.dsp = (t) => 0;
                this.port.onmessage = (event) => {
                    if (event.data.code) {
                        try {
                            const code = event.data.code.trim();
                            this.dsp = new Function('t', "return "+ code);
                        } catch (err) {}
                    }
                };
            }
            process(inputs, outputs, parameters) {
                const output = outputs[0];
                const left = output[0];
                const right = output[1];
                const vol = parameters.volume;
                const delta = parameters.speed[0];

                if (left) {
                    for (let i = 0; i < left.length; i++) {
                        let result = 0;

                        try {
                            // Some bytebeat magic, or is like floor but faster
                            result = this.dsp(this.time | 0) | 0;
                        } catch (e) {}

                        // More 8-bit magic, essentially result % 256 / 256 maps to [-1.0, 1.0]
                        const sample = ((result & 255) - 128) / 128;

                        // Handling volume automation rate
                        const currentVolume = vol.length > 1 ? vol[i] : vol[0];

                        left[i] = sample * currentVolume;
                        if (right) right[i] = left[i];

                        // Increment time based on speed parameter
                        this.time += delta;
                    }

                    // About 25% of the time, send visualizer data
                    if (((this.time | 0) & 511) < 128) {
                        this.port.postMessage(left);
                    }
                }
                return true;
            }
        }
        registerProcessor("bytebeat-processor", BytebeatProcessor);
```

</details>